package generator

import (
	"fmt"
	"path/filepath"
	"text/template"
)

// loadEmbeddedTemplates loads templates embedded in the binary
func (g *Generator) loadEmbeddedTemplates() error {
	templateFuncs := template.FuncMap{
		"ToLower":               toLower,
		"ToUpper":               toUpper,
		"ToTitle":               toTitle,
		"ToCamelCase":           toCamelCase,
		"ToSnakeCase":           toSnakeCase,
		"Pluralize":             pluralize,
		"Contains":              contains,
		"Join":                  join,
		"Quote":                 quote,
		"ConvertSchemaToGoCode": convertSchemaToGoCode,
		// Add helper functions for template generation
		"generateMethodName": generateMethodName,
		"generateToolName":   generateToolName,
	}

	g.templates = template.New("").Funcs(templateFuncs)

	// Load templates from the templates directory
	templatesDir := filepath.Join("pkg", "generator", "templates")
	pattern := filepath.Join(templatesDir, "*.tmpl")

	templates, err := g.templates.ParseGlob(pattern)
	if err != nil {
		// If we can't find the templates directory, create basic templates inline
		return g.createInlineTemplates()
	}

	g.templates = templates
	return nil
}

// createInlineTemplates creates basic templates inline when template files aren't available
func (g *Generator) createInlineTemplates() error {
	templateFuncs := template.FuncMap{
		"ToLower":               toLower,
		"ToUpper":               toUpper,
		"ToTitle":               toTitle,
		"ToCamelCase":           toCamelCase,
		"ToSnakeCase":           toSnakeCase,
		"Pluralize":             pluralize,
		"Contains":              contains,
		"Join":                  join,
		"Quote":                 quote,
		"ConvertSchemaToGoCode": convertSchemaToGoCode,
		"generateMethodName":    generateMethodName,
		"generateToolName":      generateToolName,
	}

	g.templates = template.New("").Funcs(templateFuncs)

	// Basic toolset template
	toolsetTemplate := `package {{.Package}}

// {{.CRD.Kind}}Toolset provides MCP tools for managing {{.CRD.Kind}} custom resources
type {{.CRD.Kind}}Toolset struct{}

// GetName returns the name of this toolset
func (t *{{.CRD.Kind}}Toolset) GetName() string {
	return "{{.Toolset.GetToolsetName}}"
}

// GetDescription returns the description of this toolset
func (t *{{.CRD.Kind}}Toolset) GetDescription() string {
	return "{{.Toolset.GetToolsetDescription}}"
}
`

	// Basic types template
	typesTemplate := `package {{.Package}}

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
)

// {{.CRD.Kind}} represents the {{.CRD.Kind}} custom resource
type {{.CRD.Kind}} struct {
	metav1.TypeMeta   ` + "`json:\",inline\"`" + `
	metav1.ObjectMeta ` + "`json:\"metadata,omitempty\"`" + `
	Spec   {{.CRD.Kind}}Spec   ` + "`json:\"spec,omitempty\"`" + `
	Status {{.CRD.Kind}}Status ` + "`json:\"status,omitempty\"`" + `
}

// {{.CRD.Kind}}Spec defines the desired state of {{.CRD.Kind}}
type {{.CRD.Kind}}Spec struct {
	// Add spec fields here based on CRD schema
}

// {{.CRD.Kind}}Status defines the observed state of {{.CRD.Kind}}
type {{.CRD.Kind}}Status struct {
	// Add status fields here based on CRD schema
}

// {{.CRD.ListKind}} contains a list of {{.CRD.Kind}}
type {{.CRD.ListKind}} struct {
	metav1.TypeMeta ` + "`json:\",inline\"`" + `
	metav1.ListMeta ` + "`json:\"metadata,omitempty\"`" + `
	Items           []{{.CRD.Kind}} ` + "`json:\"items\"`" + `
}

// DeepCopyInto is an autogenerated deepcopy function
func (in *{{.CRD.Kind}}) DeepCopyInto(out *{{.CRD.Kind}}) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
}

// DeepCopy is an autogenerated deepcopy function
func (in *{{.CRD.Kind}}) DeepCopy() *{{.CRD.Kind}} {
	if in == nil {
		return nil
	}
	out := new({{.CRD.Kind}})
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function
func (in *{{.CRD.Kind}}) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}
`

	// Basic client template
	clientTemplate := `package {{.Package}}

import (
	"context"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

// {{.CRD.Kind}}Client provides operations for {{.CRD.Kind}} custom resources
type {{.CRD.Kind}}Client struct {
	client    client.Client
	namespace string
}

// New{{.CRD.Kind}}Client creates a new client for {{.CRD.Kind}} resources
func New{{.CRD.Kind}}Client(c client.Client, namespace string) *{{.CRD.Kind}}Client {
	return &{{.CRD.Kind}}Client{
		client:    c,
		namespace: namespace,
	}
}

// Create creates a new {{.CRD.Kind}} resource
func (c *{{.CRD.Kind}}Client) Create(ctx context.Context, obj *{{.CRD.Kind}}) error {
	return c.client.Create(ctx, obj)
}
`

	// Basic handlers template
	handlersTemplate := `package {{.Package}}

import (
	"fmt"
)

// Basic handler implementation
func Handle{{.CRD.Kind}}Operations(operation string, params map[string]interface{}) (interface{}, error) {
	return fmt.Sprintf("Operation %s not implemented for {{.CRD.Kind}}", operation), nil
}
`

	// Basic schema template
	schemaTemplate := `package {{.Package}}

// Schema definitions for {{.CRD.Kind}}
// TODO: Implement proper JSON schemas
`

	// Basic doc template
	docTemplate := `// Package {{.Package}} provides MCP tools for managing {{.CRD.Kind}} custom resources.
//
// Generated by: mcp-toolgen
// Source CRD: {{.CRD.Name}}
package {{.Package}}
`

	// Parse inline templates
	templates := map[string]string{
		"toolset.go.tmpl":  toolsetTemplate,
		"types.go.tmpl":    typesTemplate,
		"client.go.tmpl":   clientTemplate,
		"handlers.go.tmpl": handlersTemplate,
		"schema.go.tmpl":   schemaTemplate,
		"doc.go.tmpl":      docTemplate,
	}

	for name, content := range templates {
		_, err := g.templates.New(name).Parse(content)
		if err != nil {
			return fmt.Errorf("failed to parse inline template %s: %w", name, err)
		}
	}

	return nil
}
