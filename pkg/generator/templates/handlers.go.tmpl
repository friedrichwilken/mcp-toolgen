package {{.Package}}

import (
	"errors"
	"fmt"

	"github.com/containers/kubernetes-mcp-server/pkg/api"
	internalk8s "github.com/containers/kubernetes-mcp-server/pkg/kubernetes"
	"github.com/containers/kubernetes-mcp-server/pkg/output"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/yaml"
)

{{range $operation := .Operations}}
{{if $.IncludeComments}}
// Handle{{$operation | ToTitle}}{{$.CRD.Kind}} handles {{$operation}} operations for {{$.CRD.Kind}} resources
{{end}}
func Handle{{$operation | ToTitle}}{{$.CRD.Kind}}(params api.ToolHandlerParams) (*api.ToolCallResult, error) {
	{{if eq $operation "create"}}
	return handle{{$.CRD.Kind}}Create(params)
	{{else if eq $operation "get"}}
	return handle{{$.CRD.Kind}}Get(params)
	{{else if eq $operation "list"}}
	return handle{{$.CRD.Kind}}List(params)
	{{else if eq $operation "update"}}
	return handle{{$.CRD.Kind}}Update(params)
	{{else if eq $operation "delete"}}
	return handle{{$.CRD.Kind}}Delete(params)
	{{end}}
}

{{end}}

{{if .IncludeComments}}
// handle{{.CRD.Kind}}Get retrieves a {{.CRD.Kind}} resource
{{end}}
func handle{{.CRD.Kind}}Get(params api.ToolHandlerParams) (*api.ToolCallResult, error) {
	args := params.GetArguments()

	namespace := args["namespace"]
	if namespace == nil {
		namespace = ""
	}
	name := args["name"]
	if name == nil {
		return api.NewToolCallResult("", errors.New("failed to get {{.CRD.Kind | ToLower}}, missing argument name")), nil
	}

	gvk := &schema.GroupVersionKind{
		Group:   "{{.CRD.Group}}",
		Version: "{{.CRD.Version}}",
		Kind:    "{{.CRD.Kind}}",
	}

	ns, ok := namespace.(string)
	if !ok {
		return api.NewToolCallResult("", fmt.Errorf("namespace is not a string")), nil
	}

	n, ok := name.(string)
	if !ok {
		return api.NewToolCallResult("", fmt.Errorf("name is not a string")), nil
	}

	ret, err := params.ResourcesGet(params, gvk, ns, n)
	if err != nil {
		return api.NewToolCallResult("", fmt.Errorf("failed to get {{.CRD.Kind | ToLower}}: %v", err)), nil
	}
	return api.NewToolCallResult(output.MarshalYaml(ret)), nil
}

{{if .IncludeComments}}
// handle{{.CRD.Kind}}List lists {{.CRD.Kind}} resources
{{end}}
func handle{{.CRD.Kind}}List(params api.ToolHandlerParams) (*api.ToolCallResult, error) {
	args := params.GetArguments()

	namespace := args["namespace"]
	if namespace == nil {
		namespace = ""
	}
	labelSelector := args["labelSelector"]
	resourceListOptions := internalk8s.ResourceListOptions{
		AsTable: params.ListOutput.AsTable(),
	}

	if labelSelector != nil {
		l, ok := labelSelector.(string)
		if !ok {
			return api.NewToolCallResult("", fmt.Errorf("labelSelector is not a string")), nil
		}
		resourceListOptions.LabelSelector = l
	}

	gvk := &schema.GroupVersionKind{
		Group:   "{{.CRD.Group}}",
		Version: "{{.CRD.Version}}",
		Kind:    "{{.CRD.Kind}}",
	}

	ns, ok := namespace.(string)
	if !ok {
		return api.NewToolCallResult("", fmt.Errorf("namespace is not a string")), nil
	}

	ret, err := params.ResourcesList(params, gvk, ns, resourceListOptions)
	if err != nil {
		return api.NewToolCallResult("", fmt.Errorf("failed to list {{.CRD.Plural | ToLower}}: %v", err)), nil
	}
	return api.NewToolCallResult(params.ListOutput.PrintObj(ret)), nil
}

{{if .IncludeComments}}
// handle{{.CRD.Kind}}Create creates a new {{.CRD.Kind}} resource
{{end}}
func handle{{.CRD.Kind}}Create(params api.ToolHandlerParams) (*api.ToolCallResult, error) {
	args := params.GetArguments()

	argsData := args["args"]
	if argsData == nil {
		return api.NewToolCallResult("", errors.New("failed to create {{.CRD.Kind | ToLower}}, missing argument args")), nil
	}

	// Convert structured input to YAML
	yamlBytes, err := yaml.Marshal(argsData)
	if err != nil {
		return api.NewToolCallResult("", fmt.Errorf("failed to marshal {{.CRD.Kind | ToLower}}: %v", err)), nil
	}

	// Add apiVersion and kind to the YAML
	resourceYAML := fmt.Sprintf("apiVersion: {{.CRD.Group}}/{{.CRD.Version}}\nkind: {{.CRD.Kind}}\n%s", string(yamlBytes))

	ret, err := params.ResourcesCreateOrUpdate(params, resourceYAML)
	if err != nil {
		return api.NewToolCallResult("", fmt.Errorf("failed to create {{.CRD.Kind | ToLower}}: %v", err)), nil
	}

	if len(ret) == 0 {
		return api.NewToolCallResult("", errors.New("no resources were created")), nil
	}

	return api.NewToolCallResult(output.MarshalYaml(ret[0])), nil
}

{{if .IncludeComments}}
// handle{{.CRD.Kind}}Update updates a {{.CRD.Kind}} resource
{{end}}
func handle{{.CRD.Kind}}Update(params api.ToolHandlerParams) (*api.ToolCallResult, error) {
	args := params.GetArguments()

	argsData := args["args"]
	if argsData == nil {
		return api.NewToolCallResult("", errors.New("failed to update {{.CRD.Kind | ToLower}}, missing argument args")), nil
	}

	// Convert structured input to YAML
	yamlBytes, err := yaml.Marshal(argsData)
	if err != nil {
		return api.NewToolCallResult("", fmt.Errorf("failed to marshal {{.CRD.Kind | ToLower}}: %v", err)), nil
	}

	// Add apiVersion and kind to the YAML
	resourceYAML := fmt.Sprintf("apiVersion: {{.CRD.Group}}/{{.CRD.Version}}\nkind: {{.CRD.Kind}}\n%s", string(yamlBytes))

	ret, err := params.ResourcesCreateOrUpdate(params, resourceYAML)
	if err != nil {
		return api.NewToolCallResult("", fmt.Errorf("failed to update {{.CRD.Kind | ToLower}}: %v", err)), nil
	}

	if len(ret) == 0 {
		return api.NewToolCallResult("", errors.New("no resources were updated")), nil
	}

	return api.NewToolCallResult(output.MarshalYaml(ret[0])), nil
}

{{if .IncludeComments}}
// handle{{.CRD.Kind}}Delete deletes a {{.CRD.Kind}} resource
{{end}}
func handle{{.CRD.Kind}}Delete(params api.ToolHandlerParams) (*api.ToolCallResult, error) {
	args := params.GetArguments()

	namespace := args["namespace"]
	if namespace == nil {
		namespace = ""
	}
	name := args["name"]
	if name == nil {
		return api.NewToolCallResult("", errors.New("failed to delete {{.CRD.Kind | ToLower}}, missing argument name")), nil
	}

	gvk := &schema.GroupVersionKind{
		Group:   "{{.CRD.Group}}",
		Version: "{{.CRD.Version}}",
		Kind:    "{{.CRD.Kind}}",
	}

	ns, ok := namespace.(string)
	if !ok {
		return api.NewToolCallResult("", fmt.Errorf("namespace is not a string")), nil
	}

	n, ok := name.(string)
	if !ok {
		return api.NewToolCallResult("", fmt.Errorf("name is not a string")), nil
	}

	err := params.ResourcesDelete(params, gvk, ns, n)
	if err != nil {
		return api.NewToolCallResult("", fmt.Errorf("failed to delete {{.CRD.Kind | ToLower}} %s: %v", n, err)), nil
	}

	return api.NewToolCallResult(fmt.Sprintf("{{.CRD.Kind}} %s deleted successfully", n), nil), nil
}
